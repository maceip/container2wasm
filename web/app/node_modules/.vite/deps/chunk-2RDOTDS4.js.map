{
  "version": 3,
  "sources": ["../../@base-ui/utils/esm/mergeObjects.js", "../../@base-ui/react/esm/merge-props/mergeProps.js"],
  "sourcesContent": ["export function mergeObjects(a, b) {\n  if (a && !b) {\n    return a;\n  }\n  if (!a && b) {\n    return b;\n  }\n  if (a || b) {\n    return {\n      ...a,\n      ...b\n    };\n  }\n  return undefined;\n}", "import { mergeObjects } from '@base-ui/utils/mergeObjects';\nconst EMPTY_PROPS = {};\n\n/**\n * Merges multiple sets of React props. It follows the Object.assign pattern where the rightmost object's fields overwrite\n * the conflicting ones from others. This doesn't apply to event handlers, `className` and `style` props.\n * Event handlers are merged such that they are called in sequence (the rightmost one being called first),\n * and allows the user to prevent the subsequent event handlers from being\n * executed by attaching a `preventBaseUIHandler` method.\n * It also merges the `className` and `style` props, whereby the classes are concatenated\n * and the rightmost styles overwrite the subsequent ones.\n *\n * Props can either be provided as objects or as functions that take the previous props as an argument.\n * The function will receive the merged props up to that point (going from left to right):\n * so in the case of `(obj1, obj2, fn, obj3)`, `fn` will receive the merged props of `obj1` and `obj2`.\n * The function is responsible for chaining event handlers if needed (i.e. we don't run the merge logic).\n *\n * Event handlers returned by the functions are not automatically prevented when `preventBaseUIHandler` is called.\n * They must check `event.baseUIHandlerPrevented` themselves and bail out if it's true.\n *\n * @important **`ref` is not merged.**\n * @param props props to merge.\n * @returns the merged props.\n */\n/* eslint-disable id-denylist */\n\nexport function mergeProps(a, b, c, d, e) {\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(a, EMPTY_PROPS)\n  };\n  if (b) {\n    merged = mergeOne(merged, b);\n  }\n  if (c) {\n    merged = mergeOne(merged, c);\n  }\n  if (d) {\n    merged = mergeOne(merged, d);\n  }\n  if (e) {\n    merged = mergeOne(merged, e);\n  }\n  return merged;\n}\n/* eslint-enable id-denylist */\n\nexport function mergePropsN(props) {\n  if (props.length === 0) {\n    return EMPTY_PROPS;\n  }\n  if (props.length === 1) {\n    return resolvePropsGetter(props[0], EMPTY_PROPS);\n  }\n\n  // We need to mutably own `merged`\n  let merged = {\n    ...resolvePropsGetter(props[0], EMPTY_PROPS)\n  };\n  for (let i = 1; i < props.length; i += 1) {\n    merged = mergeOne(merged, props[i]);\n  }\n  return merged;\n}\nfunction mergeOne(merged, inputProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(merged);\n  }\n  return mutablyMergeInto(merged, inputProps);\n}\n\n/**\n * Merges two sets of props. In case of conflicts, the external props take precedence.\n */\nfunction mutablyMergeInto(mergedProps, externalProps) {\n  if (!externalProps) {\n    return mergedProps;\n  }\n\n  // eslint-disable-next-line guard-for-in\n  for (const propName in externalProps) {\n    const externalPropValue = externalProps[propName];\n    switch (propName) {\n      case 'style':\n        {\n          mergedProps[propName] = mergeObjects(mergedProps.style, externalPropValue);\n          break;\n        }\n      case 'className':\n        {\n          mergedProps[propName] = mergeClassNames(mergedProps.className, externalPropValue);\n          break;\n        }\n      default:\n        {\n          if (isEventHandler(propName, externalPropValue)) {\n            mergedProps[propName] = mergeEventHandlers(mergedProps[propName], externalPropValue);\n          } else {\n            mergedProps[propName] = externalPropValue;\n          }\n        }\n    }\n  }\n  return mergedProps;\n}\nfunction isEventHandler(key, value) {\n  // This approach is more efficient than using a regex.\n  const code0 = key.charCodeAt(0);\n  const code1 = key.charCodeAt(1);\n  const code2 = key.charCodeAt(2);\n  return code0 === 111 /* o */ && code1 === 110 /* n */ && code2 >= 65 /* A */ && code2 <= 90 /* Z */ && (typeof value === 'function' || typeof value === 'undefined');\n}\nfunction isPropsGetter(inputProps) {\n  return typeof inputProps === 'function';\n}\nfunction resolvePropsGetter(inputProps, previousProps) {\n  if (isPropsGetter(inputProps)) {\n    return inputProps(previousProps);\n  }\n  return inputProps ?? EMPTY_PROPS;\n}\nfunction mergeEventHandlers(ourHandler, theirHandler) {\n  if (!theirHandler) {\n    return ourHandler;\n  }\n  if (!ourHandler) {\n    return theirHandler;\n  }\n  return event => {\n    if (isSyntheticEvent(event)) {\n      const baseUIEvent = event;\n      makeEventPreventable(baseUIEvent);\n      const result = theirHandler(baseUIEvent);\n      if (!baseUIEvent.baseUIHandlerPrevented) {\n        ourHandler?.(baseUIEvent);\n      }\n      return result;\n    }\n    const result = theirHandler(event);\n    ourHandler?.(event);\n    return result;\n  };\n}\nexport function makeEventPreventable(event) {\n  event.preventBaseUIHandler = () => {\n    event.baseUIHandlerPrevented = true;\n  };\n  return event;\n}\nexport function mergeClassNames(ourClassName, theirClassName) {\n  if (theirClassName) {\n    if (ourClassName) {\n      // eslint-disable-next-line prefer-template\n      return theirClassName + ' ' + ourClassName;\n    }\n    return theirClassName;\n  }\n  return ourClassName;\n}\nfunction isSyntheticEvent(event) {\n  return event != null && typeof event === 'object' && 'nativeEvent' in event;\n}"],
  "mappings": "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",
  "names": ["result"]
}
