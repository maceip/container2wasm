"use client";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/vaso/dist/index.js
var import_react = __toESM(require_react());
var distortionIntensity = 0.15;
var roundness = 0.6;
var shapeWidth = 0.3;
var shapeHeight = 0.2;
var rAF = typeof window !== "undefined" ? window.requestAnimationFrame || setTimeout : () => 0;
var createBackdropFilter = (uid, blur) => `url(#${uid}_filter) blur(${blur}px) contrast(1.1) brightness(1.05) saturate(1.1)`;
function smoothStep(a, b, t) {
  t = Math.max(0, Math.min(1, (t - a) / (b - a)));
  return t * t * (3 - 2 * t);
}
function length(x, y) {
  return Math.sqrt(x * x + y * y);
}
function roundedRectSDF(x, y, width, height, radius) {
  const absWidth = Math.abs(width);
  const absHeight = Math.abs(height);
  const absRadius = Math.abs(radius);
  const qx = Math.abs(x) - absWidth + absRadius;
  const qy = Math.abs(y) - absHeight + absRadius;
  const distance = Math.min(Math.max(qx, qy), 0) + length(Math.max(qx, 0), Math.max(qy, 0)) - absRadius;
  return width < 0 || height < 0 ? -distance : distance;
}
function createDisplacementFragment(uv, intensity = 0.15, depth = 0) {
  const ix = uv.x - 0.5;
  const iy = uv.y - 0.5;
  const distanceToEdge = roundedRectSDF(ix, iy, Math.abs(shapeWidth), Math.abs(shapeHeight), Math.abs(roundness));
  const displacement = smoothStep(0.8, 0, distanceToEdge - Math.abs(intensity));
  const scaled = smoothStep(0, 1, displacement);
  const depthReverse = depth < 0;
  const intensityReverse = intensity < 0;
  let effectMultiplier = scaled;
  if (depthReverse || intensityReverse) {
    effectMultiplier = 1 - scaled * 0.7;
  }
  const finalX = ix * effectMultiplier + 0.5;
  const finalY = iy * effectMultiplier + 0.5;
  return {
    x: finalX,
    y: finalY
  };
}
var generateDisplacementData = /* @__PURE__ */ (() => {
  const cache = /* @__PURE__ */ new Map();
  return (width, height, intensity = 0.15, shapeWidth2 = 0.3, shapeHeight2 = 0.2, depth = 1) => {
    const key = `${width}-${height}-${intensity}-${shapeWidth2}-${shapeHeight2}-${depth}`;
    if (cache.has(key)) {
      return cache.get(key);
    }
    if (!width || !height || width <= 0 || height <= 0 || !Number.isFinite(width) || !Number.isFinite(height)) {
      console.warn("Invalid canvas dimensions:", {
        width,
        height
      });
      return {
        data: new Uint8ClampedArray(4),
        maxScale: 0
      };
    }
    const w = Math.floor(width);
    const h = Math.floor(height);
    const data = new Uint8ClampedArray(w * h * 4);
    const rawValues = [];
    let maxScale = 0;
    for (let i = 0; i < data.length; i += 4) {
      const x = i / 4 % w;
      const y = Math.floor(i / 4 / w);
      const uv = {
        x: x / w,
        y: y / h
      };
      const pos = createDisplacementFragment(uv, intensity, depth);
      const dx = pos.x * w - x;
      const dy = pos.y * h - y;
      maxScale = Math.max(maxScale, Math.abs(dx), Math.abs(dy));
      rawValues.push(dx, dy);
    }
    maxScale *= 0.5;
    let index = 0;
    for (let i = 0; i < data.length; i += 4) {
      const r = rawValues[index++] / maxScale + 0.5;
      const g = rawValues[index++] / maxScale + 0.5;
      data[i] = r * 255;
      data[i + 1] = g * 255;
      data[i + 2] = 0;
      data[i + 3] = 255;
    }
    const result = {
      data,
      maxScale
    };
    if (cache.size > 10) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    cache.set(key, result);
    return result;
  };
})();
var Vaso = ({ component: WrapComponent = "div", children, width, height, px = 0, py = 0, radius = 0, depth = 0, blur = 0.1, dispersion = 0.5, ...htmlProps }) => {
  var _a;
  const uid = (0, import_react.useId)();
  const wrapperRef = (0, import_react.useRef)(null);
  const canvasRef = (0, import_react.useRef)(null);
  const containerRef = (0, import_react.useRef)(null);
  const feImageRef = (0, import_react.useRef)(null);
  const feDisplacementMapRef = (0, import_react.useRef)(null);
  const animationFrameRef = (0, import_react.useRef)(null);
  const updateEffectRef = (0, import_react.useRef)(null);
  const scheduleUpdate = (0, import_react.useCallback)(() => {
    if (updateEffectRef.current) {
      cancelAnimationFrame(updateEffectRef.current);
    }
    const reposition = () => {
      var _a2, _b;
      const targetEl = wrapperRef.current;
      const canvas = canvasRef.current;
      const feImage = feImageRef.current;
      const feDisplacementMap = feDisplacementMapRef.current;
      const container = containerRef.current;
      if (!targetEl || !canvas || !feImage || !feDisplacementMap || !container) {
        return;
      }
      const rect = targetEl.getBoundingClientRect();
      if (width !== void 0) rect.width = width;
      if (height !== void 0) rect.height = height;
      const finalWidth = Math.max(1, rect.width + 2 * px);
      const finalHeight = Math.max(1, rect.height + 2 * py);
      container.style.width = `${finalWidth}px`;
      container.style.height = `${finalHeight}px`;
      const shadowWidth = finalWidth;
      const shadowHeight = finalHeight;
      const shadowScale = Math.min(Math.max(shadowWidth + shadowHeight, 100), 800) / 400;
      const blurRadius = Math.round(4 * shadowScale);
      const spreadRadius = Math.round(8 * shadowScale);
      const insetBlur = Math.round(20 * shadowScale);
      const insetOffset = Math.round(-10 * shadowScale);
      container.style.boxShadow = `0 ${blurRadius}px ${spreadRadius}px rgba(0, 0, 0, 0.2), 0 ${insetOffset}px ${insetBlur}px inset rgba(0, 0, 0, 0.15)`;
      const canvasDPI = 0.75;
      const canvasWidth = Math.max(1, Math.floor(finalWidth * canvasDPI));
      const canvasHeight = Math.max(1, Math.floor(finalHeight * canvasDPI));
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const context = canvas.getContext("2d");
      if (!context) return;
      try {
        const { data, maxScale } = generateDisplacementData(canvasWidth, canvasHeight, distortionIntensity, shapeWidth, shapeHeight, depth);
        if (data.length >= 4 && canvasWidth > 0 && canvasHeight > 0) {
          const imageData = new ImageData(data, canvasWidth, canvasHeight);
          context.putImageData(imageData, 0, 0);
          feImage.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL());
          feImage.setAttribute("width", `${finalWidth}`);
          feImage.setAttribute("height", `${finalHeight}`);
          const finalScale = Math.max(0, maxScale * Math.abs(depth) / canvasDPI);
          feDisplacementMap.setAttribute("scale", finalScale.toString());
          (_a2 = feDisplacementMap.parentElement) == null ? void 0 : _a2.setAttribute("width", `${finalWidth}`);
          (_b = feDisplacementMap.parentElement) == null ? void 0 : _b.setAttribute("height", `${finalHeight}`);
          container.style.backdropFilter = createBackdropFilter(uid, blur);
        }
      } catch (error) {
        console.error(error);
      }
    };
    updateEffectRef.current = rAF(reposition);
  }, [
    width,
    height,
    px,
    py,
    depth,
    blur,
    dispersion,
    distortionIntensity,
    roundness,
    shapeWidth,
    shapeHeight,
    uid
  ]);
  (0, import_react.useLayoutEffect)(() => {
    scheduleUpdate();
  }, [
    scheduleUpdate
  ]);
  (0, import_react.useEffect)(() => {
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      if (updateEffectRef.current) {
        cancelAnimationFrame(updateEffectRef.current);
      }
    };
  }, []);
  return import_react.default.createElement(WrapComponent, {
    ...htmlProps,
    style: {
      position: "relative"
    },
    // @ts-expect-error: dynamic ref assignment, improve this ref type later
    ref: wrapperRef
  }, import_react.default.createElement(WrapComponent, {
    "data-vaso": uid,
    // @ts-expect-error: dynamic ref assignment, improve this ref type later
    ref: containerRef,
    style: {
      position: "absolute",
      top: -py,
      left: -px,
      width: `calc(100% + ${px * 2}px)`,
      height: `calc(100% + ${py * 2}px)`,
      overflow: "hidden",
      backdropFilter: createBackdropFilter(uid, blur),
      ...radius && {
        borderRadius: radius
      },
      cursor: "default",
      userSelect: "none"
    }
  }), import_react.default.createElement("svg", {
    width: "0",
    height: "0",
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      zIndex: ((_a = htmlProps.style) == null ? void 0 : _a.zIndex) || 999
    }
  }, import_react.default.createElement("defs", null, import_react.default.createElement("filter", {
    id: `${uid}_filter`,
    filterUnits: "userSpaceOnUse",
    colorInterpolationFilters: "sRGB",
    x: "-5%",
    y: "-5%",
    width: "110%",
    height: "110%"
  }, import_react.default.createElement("feImage", {
    ref: feImageRef,
    id: `${uid}_map`
  }), import_react.default.createElement("feDisplacementMap", {
    ref: feDisplacementMapRef,
    in: "SourceGraphic",
    in2: `${uid}_map`,
    xChannelSelector: "R",
    yChannelSelector: "G",
    result: "displaced"
  }), dispersion && import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("feOffset", {
    dx: dispersion,
    dy: dispersion,
    in: "displaced",
    result: "redShift"
  }), import_react.default.createElement("feOffset", {
    dx: "0",
    dy: "0",
    in: "displaced",
    result: "greenCenter"
  }), import_react.default.createElement("feOffset", {
    dx: -dispersion,
    dy: -dispersion,
    in: "displaced",
    result: "blueShift"
  }), import_react.default.createElement("feColorMatrix", {
    in: "redShift",
    type: "matrix",
    values: "1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0",
    result: "redOnly"
  }), import_react.default.createElement("feColorMatrix", {
    in: "greenCenter",
    type: "matrix",
    values: "0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0",
    result: "greenOnly"
  }), import_react.default.createElement("feColorMatrix", {
    in: "blueShift",
    type: "matrix",
    values: "0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0",
    result: "blueOnly"
  }), import_react.default.createElement("feComposite", {
    in: "redOnly",
    in2: "greenOnly",
    operator: "lighter",
    result: "redGreen"
  }), import_react.default.createElement("feComposite", {
    in: "redGreen",
    in2: "blueOnly",
    operator: "lighter"
  }))))), import_react.default.createElement("canvas", {
    ref: canvasRef,
    style: {
      display: "none"
    }
  }), children);
};
export {
  Vaso
};
//# sourceMappingURL=vaso.js.map
