<html>
  <head>
    <title>container on browser</title>
    <link rel="stylesheet" href="./xterm.css" />
  </head>
  <body>
    <div id="terminal"></div>
    <script src="./load.js"></script>
    <script src="./dist/stack.js"></script>
    <script type="module">
      import 'https://unpkg.com/xterm@5.3.0/lib/xterm.js';
      import 'https://unpkg.com/xterm-pty/index.js';
      import './arg-module.js'
      import initEmscriptenModule from './out.js';
      import { OPFSFilesystem } from './opfs-fs-backend.js';
      import { Virtio9p } from './9p.js';
      import { connectSyncAgent } from 'https://esm.sh/happy-opfs@latest';

      const xterm = new Terminal();
      xterm.open(document.getElementById("terminal"));

      const { master, slave } = openpty();

      xterm.loadAddon(master);

      Module.pty = slave;

      Module['mainScriptUrlOrBlob'] = location.origin + "/out.js";

      let info = "t:" + Math.round(new Date() / 1000) + "\n";
      
      var netParam = getNetParam();
      if (!netParam) {
          start(info);
      } else {
          if (netParam.mode == 'delegate') {
              Module['websocket'] = {
                  'url': netParam.param
              };
              info += 'n:' + genmac() + '\n';
              start(info);
          } else if (netParam.mode == 'browser') {
              const stackAddress = 'http://localhost:9999/'; // listened and served by MSW inside browser
              const stackWorkerFile = location.origin + "/dist/stack-worker.js";
              const stackImage = location.origin + "/c2w-net-proxy.wasm.gzip";
              Module['websocket'] = {
                  'url': stackAddress
              };
              Stack.Start(stackAddress, stackWorkerFile, stackImage, (cert) => {
                  Module['preRun'].push((mod) => {
                      mod.FS.mkdir('/.wasmenv');
                      mod.FS.writeFile('/.wasmenv/proxy.crt', cert);
                  });
                  info += 'n:' + genmac() + '\n';
                  info += `m: .wasmenv
env: SSL_CERT_FILE=/.wasmenv/proxy.crt
env: https_proxy=http://192.168.127.253:80
env: http_proxy=http://192.168.127.253:80
env: HTTPS_PROXY=http://192.168.127.253:80
env: HTTP_PROXY=http://192.168.127.253:80`;
                  start(info);
              });
          }
      }
      function start(info) {
          Module['preRun'].push((mod) => {
              mod.FS.mkdir('/pack');
              mod.FS.writeFile('/pack/info', info);
          });
          (async () => {
              // Initialize OPFS for 9P server
              const opfsWorkerUrl = new URL('./opfs-worker.js', import.meta.url);
              await connectSyncAgent(opfsWorkerUrl);
              const opfsFs = new OPFSFilesystem('/shared'); // Mounts /shared from OPFS

              const instance = await initEmscriptenModule(Module);
              
              // This is the tricky part. The plan assumes a v86-like bus.
              // QEMU-WASM might not have `instance.bus`.
              // We'll need to find the correct way to connect virtio.
              // For now, we'll try to instantiate it, assuming it will fail
              // but demonstrating the intent.
              if (instance.bus) {
                  const virtio9p = new Virtio9p(opfsFs, instance.cpu, instance.bus);
                  // v86's 9p.js registers itself as a virtio device.
                  // It uses a device tag "host9p". We might need to change it to "opfs".
                  // TODO: Check QEMU-WASM virtio device registration from JS.
              } else {
                  console.warn("L1/M1 Integration: Could not find `instance.bus`. 9P OPFS share is not active.");
              }

              var oldPoll = Module['TTY'].stream_ops.poll;
              var pty = Module['pty'];
              Module['TTY'].stream_ops.poll = function(stream, timeout){
                  if (!pty.readable) {
                      return (pty.readable ? 1 : 0) | (pty.writable ? 4 : 0);
                  }
                  return oldPoll.call(stream, timeout);
              }
          })();
      }
      function getNetParam() {
          var vars = location.search.substring(1).split('&');
          for (var i = 0; i < vars.length; i++) {
              var kv = vars[i].split('=');
              if (decodeURIComponent(kv[0]) == 'net') {
                  return {
                      mode: kv[1],
                      param: kv[2],
                  };
              }
          }
          return null;
      }
      function genmac(){
          return "02:XX:XX:XX:XX:XX".replace(/X/g, function() {
              return "0123456789ABCDEF".charAt(Math.floor(Math.random() * 16))
          });
      }
    </script>
  </body>
</html>
